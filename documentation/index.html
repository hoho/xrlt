---
layout: default
title: Documentation
section: Documentation
---
<h3 id="intro">Introduction</h3>
<p>Before we begin, let's talk buzzwords. I hope reader is familiar with
<a href="http://en.wikipedia.org/wiki/XML">XML</a> and
<a href="http://en.wikipedia.org/wiki/XPath">XPath</a>,
<a href="http://en.wikipedia.org/wiki/JavaScript">JavaScript</a>,
<a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a>,
<a href="http://en.wikipedia.org/wiki/Asynchronous_I/O">Asynchronous I/O</a>
and <a href="http://en.wikipedia.org/wiki/XSLT">XSLT</a>. Guess, familiarity
with these, guarantees familiarity with all the rest terms that would be
used. You could move straight to <a href="/documentation/#syntax">Syntax</a>
chapter to see XRLT examples.</p>

<h3 id="frontends">About Frontends and XRLT</h3>
<p>Frontend is a thing takes data from backend and transforms it to view.
Frontend is also a thing takes user's input and transmits it to backend.
For our purposes, backend is just some black box, that gives and takes
data.</p>

<p>XRLT is for creating frontends. It is a server-side scripting language.
Something like <a href="http://en.wikipedia.org/wiki/PHP">PHP</a>, but almost
completely different.</p>

<p>The main difference is that XRLT is not a general-purpose language. You can
run spaceships with things like PHP, but that leads to a countless number of
ways to do the same. XRLT has a very limited set of instructions. It aims to
standardize and simplify common frontend development scenarios.</p>

<h3 id="xmljs">Melting XML and JavaScript Down</h3>
<p>We have HTML and JavaScript for web-pages. The skeleton is XML-based and all
the dynamic is mostly about JavaScript.</p>

<p>So, in XRLT we stick XML and JavaScript together. And it would be great if
the stitches cause no pain.</p>

<p>This takes us to data representation in XML and
<a href="http://en.wikipedia.org/wiki/JSON">JavaScript</a>.</p>

<h3 id="rddm">Reasonably-Destructive Data Mapping</h3>
<p>There are ways to map
<a href="http://msdn.microsoft.com/en-us/library/bb924435.aspx">JSON to XML</a>
or back non-destructively. But let's say, we don't need non-destructivity
completely. Then we could get a cosy way to address elements in both XML and
JSON.</p>

<p>The structure: {% highlight javascript %}{
    "root": {
        "hello": "123",
        "world": "yo",
        "this": [
            "1", "2", 3
        ],
        "is": {
            "very": true,
            "cool": [
                4, "5", {"really": "is"}
            ]
        }
    }
}{% endhighlight %}</p>

<p>is being mapped to (and back): {% highlight xml %}<root>
    <hello>123</hello>
    <world>yo</world>
    <this>1</this>
    <this>2</this>
    <this xrl:type="number">3</this>
    <is>
        <very xrl:type="boolean">true</very>
        <cool xrl:type="number">4</cool>
        <cool>5</cool>
        <cool>
            <really>is</really>
        </cool>
    </is>
</root>{% endhighlight %}</p>

<p>This mapping is a bit destructive (we'll get back to it's destructivity
later). But it has pros.</p>

<p>Pending.</p>

<h3 id="syntax">Syntax</h3>
<p>Pending.</p>

<h3 id="basic">Basic Instructions</h3>
<p>Pending.</p>

<h3 id="includes">Data Including</h3>
<p>Pending.</p>

<h3 id="templates">Templates</h3>
<p>Pending.</p>

<h3 id="forms">Form Validation</h3>
<p>Pending.</p>

<h3 id="request">Request Information</h3>
<p>Pending.</p>

<h3 id="caching">Caching</h3>
<p>Pending.</p>

<h3 id="moar">Moar</h3>
<p>Pending.</p>
