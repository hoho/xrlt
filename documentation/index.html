---
layout: default
title: Documentation
section: Documentation
---
<h3 id="intro" xmlns="http://www.w3.org/1999/html"
    xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html"
    xmlns="http://www.w3.org/1999/html">Introduction</h3>
<p>Before we begin, let's talk buzzwords. I hope reader is familiar with
<a href="http://en.wikipedia.org/wiki/XML">XML</a> and
<a href="http://en.wikipedia.org/wiki/XPath">XPath</a>,
<a href="http://en.wikipedia.org/wiki/JavaScript">JavaScript</a> and
<a href="http://en.wikipedia.org/wiki/JSON">JSON</a>,
<a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a>,
<a href="http://en.wikipedia.org/wiki/Asynchronous_I/O">Asynchronous I/O</a>
and <a href="http://en.wikipedia.org/wiki/XSLT">XSLT</a>. Guess, familiarity
with these, guarantees familiarity with all the rest terms that would be
used. You could move straight to <a href="/documentation/#syntax">Syntax</a>
chapter to see XRLT examples.</p>

<h3 id="frontends">About Frontends and XRLT</h3>
<p>Frontend is a thing takes data from backend and transforms it to view.
Frontend is also a thing takes user's input and transmits it to backend.
For our purposes, backend is just some black box, that gives and takes
data.</p>

<p>XRLT is for creating frontends. It is a server-side scripting language.
Something like <a href="http://en.wikipedia.org/wiki/PHP">PHP</a>, but almost
completely different.</p>

<p>The main difference is that XRLT is not a general-purpose language. You can
run spaceships with things like PHP, but that leads to a countless number of
ways to do the same. XRLT has a very limited set of instructions. It aims to
standardize and simplify common frontend development scenarios.</p>

<p>Server-side goal of building a web-page is to build a tree, usually.
HTML (XML) tree or JSON tree. XRLT is designed to build trees. From another
trees, subtrees and funny bushes (from backend's data and from user's
input).</p>

<h3 id="xmljs">Melting XML and JavaScript Down</h3>
<p>We have HTML and JavaScript for web-pages. The skeleton is XML-based and all
the dynamic is mostly about JavaScript.</p>

<p>Most backends give us JSON or XML. Sometimes it's necessary to work with
both at the same project.</p>

<p>So, in XRLT we stick XML and JavaScript together. And it would be great if
the stitches cause no pain.</p>

<h3 id="syntax">Syntax</h3>
<p><div class="highlight"><pre><code class="xml"><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="nt">&lt;xrl:requestsheet</span> <span class="na">xmlns:xrl=</span><span class="s">&quot;http://xrlt.net/Transform&quot;</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- Slices are functions of XRLT. Unnamed slices are applied in-place,</span>
<span class="c">         named slices should be applied with &lt;xrl:apply&gt; instruction (or</span>
<span class="c">         apply() JavaScript function (in case of JavaScript slices).</span>

<span class="c">         For the moment, there are two types of slices: XML-slices (default)</span>
<span class="c">         and JavaScript-slices. --&gt;</span>
    <span class="nt">&lt;xrl:slice&gt;</span>
        <span class="c">&lt;!-- We&#39;re inside of unnamed XML-slice. It will apply in-place.</span>
<span class="c">             So, from here XRLT processor will walk through slice&#39;s nodes.</span>
<span class="c">             Unknown nodes will be just copied to the result tree,</span>
<span class="c">             XRLT-instructions will be processed. --&gt;</span>
        <span class="nt">&lt;root&gt;</span><span class="c">&lt;!-- Copy node to result tree. --&gt;</span>
            <span class="nt">&lt;xrl:apply</span> <span class="na">name=</span><span class="s">&quot;xml-slice&quot;</span><span class="nt">&gt;</span>
                <span class="c">&lt;!-- Apply named slice with parameter. --&gt;</span>
                <span class="nt">&lt;xrl:with-param</span> <span class="na">name=</span><span class="s">&quot;p1&quot;</span><span class="nt">&gt;</span>yo<span class="nt">&lt;/xrl:with-param&gt;</span>
            <span class="nt">&lt;/xrl:apply&gt;</span>
            <span class="nt">&lt;xrl:apply</span> <span class="na">name=</span><span class="s">&quot;js-slice&quot;</span><span class="nt">&gt;</span>
                <span class="c">&lt;!-- Apply another named slice with parameter. --&gt;</span>
                <span class="nt">&lt;xrl:with-param</span> <span class="na">name=</span><span class="s">&quot;p2&quot;</span><span class="nt">&gt;</span>
                    <span class="nt">&lt;boo&gt;</span>
                        <span class="nt">&lt;foo&gt;</span>moo<span class="nt">&lt;/foo&gt;</span>
                    <span class="nt">&lt;/boo&gt;</span>
                <span class="nt">&lt;/xrl:with-param&gt;</span>
            <span class="nt">&lt;/xrl:apply&gt;</span>
        <span class="nt">&lt;/root&gt;</span>
    <span class="nt">&lt;/xrl:slice&gt;</span>

    <span class="nt">&lt;xrl:slice</span> <span class="na">name=</span><span class="s">&quot;xml-slice&quot;</span><span class="nt">&gt;</span>
        <span class="c">&lt;!-- Named XML-slice. --&gt;</span>
        <span class="nt">&lt;xrl:param</span> <span class="na">name=</span><span class="s">&quot;p1&quot;</span> <span class="nt">/&gt;</span><span class="c">&lt;!-- Parameter p1 could be given. --&gt;</span>
        <span class="nt">&lt;hello-from-xml&gt;</span><span class="c">&lt;!-- Copy node to the result tree. --&gt;</span>
            <span class="nt">&lt;hi&gt;</span><span class="c">&lt;!-- Copy node to the result tree. --&gt;</span>
                <span class="c">&lt;!-- Evaluate XPath-expression and add evaluation result to</span>
<span class="c">                     the result tree. --&gt;</span>
                <span class="nt">&lt;xrl:value-of</span>
                    <span class="na">select=</span><span class="s">&quot;concat(&#39;hello&#39;, &#39; from &#39;, &#39;xml &#39;, $p1)&quot;</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/hi&gt;</span>
        <span class="nt">&lt;/hello-from-xml&gt;</span>
    <span class="nt">&lt;/xrl:slice&gt;</span>

    <span class="nt">&lt;xrl:slice</span> <span class="na">name=</span><span class="s">&quot;js-slice&quot;</span> <span class="na">type=</span><span class="s">&quot;javascript&quot;</span><span class="nt">&gt;</span>
        <span class="c">&lt;!-- Named JavaScript-slice. Parameter&#39;s p2 async=&quot;yes&quot; attribute</span>
<span class="c">             means, we don&#39;t want to wait for p2 parameter to be ready (say,</span>
<span class="c">             p2 contains yet unfinished backend request result). --&gt;</span>
        <span class="nt">&lt;xrl:param</span> <span class="na">name=</span><span class="s">&quot;p2&quot;</span> <span class="na">async=</span><span class="s">&quot;yes&quot;</span> <span class="nt">/&gt;</span>
        <span class="cp">&lt;![CDATA[</span>
            <span class="c1">// We can freely apply JavaScript-slices from XML-slices and</span>
            <span class="c1">// XML-slices from JavaScript-slices: parameters and the result</span>
            <span class="c1">// will be automatically mapped between XML and JSON using</span>
            <span class="c1">// reasonably-destructive data mapping.</span>

            <span class="c1">// We can return any JSON-serializable object as the result or</span>
            <span class="c1">// Deferred-object, if we need to get the result asynchronously.</span>
            <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Deferred</span><span class="p">();</span>

            <span class="c1">// Parameters are available as scope variables. When we have</span>
            <span class="c1">// async=&quot;yes&quot; in parameter&#39;s declaration, we get Deferred-object</span>
            <span class="c1">// in parameter&#39;s variable.</span>
            <span class="nx">p2</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Slice parameters&#39; values are immutable, so, we have to copy</span>
                <span class="c1">// value, if we want to change it.</span>
                <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">copy</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>

                <span class="c1">// &lt;boo&gt;&lt;foo&gt;moo&lt;/foo&gt;&lt;/boo&gt; is passed to this slice, and</span>
                <span class="c1">// automatically mapped to {&quot;boo&quot;: {&quot;foo&quot;: &quot;moo&quot;}}.</span>
                <span class="c1">// Let&#39;s add something to foo property.</span>
                <span class="nx">p</span><span class="p">.</span><span class="nx">boo</span><span class="p">.</span><span class="nx">foo</span> <span class="o">+=</span> <span class="s1">&#39; yep&#39;</span><span class="p">;</span>

                <span class="c1">// Apply XML-slice with parameter p1.</span>
                <span class="kd">var</span> <span class="nx">xmlSliceResult</span> <span class="o">=</span> <span class="nx">apply</span><span class="p">(</span><span class="s1">&#39;xml-slice&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">p1</span><span class="o">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()});</span>

                <span class="c1">// The result will be:</span>
                <span class="c1">// {</span>
                <span class="c1">//     &quot;hello-from-js&quot;: {</span>
                <span class="c1">//         &quot;test&quot;: {&quot;boo&quot;: {&quot;foo&quot;: &quot;moo yep&quot;}},</span>
                <span class="c1">//         &quot;test2&quot;: ... — result of xml-slice.</span>
                <span class="c1">//     }</span>
                <span class="c1">// }</span>
                <span class="nx">ret</span><span class="p">.</span><span class="nx">resolve</span><span class="p">({</span>
                    <span class="s1">&#39;hello-from-js&#39;</span><span class="o">:</span> <span class="p">{</span>
                        <span class="nx">test</span><span class="o">:</span> <span class="nx">p</span><span class="p">,</span>
                        <span class="nx">test2</span><span class="o">:</span> <span class="nx">xmlSliceResult</span>
                    <span class="p">}</span>
                <span class="p">});</span>
            <span class="p">});</span>

            <span class="c1">// Return Deferred-object.</span>
            <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
        <span class="cp">]]&gt;</span>
    <span class="nt">&lt;/xrl:slice&gt;</span>

<span class="nt">&lt;/xrl:requestsheet&gt;</span>
</code></pre>
</div></p>


<p>This transformation's result will look like:
{% highlight xml %}<root>
    <hello-from-xml>
        <hi>hello from xml yo</hi>
    </hello-from-xml>
    <hello-from-js>
        <test>
            <boo>
                <foo>moo yep</foo>
            </boo>
        </test>
        <test2>
            <hello-from-xml>
                <hi>hello from xml 2012-09-15T00:00:22.661Z</hi>
            </hello-from-xml>
        </test2>
    </hello-from-js>
</root>{% endhighlight %}</p>

<p>Or (if we declare JSON output):
{% highlight javascript %}{
    "root": {
        "hello-from-xml": {"hi": "hello from xml yo"},
        "hello-from-js": {
            "test": {"boo": {"foo": "moo yep"}},
            "test2": {
                "hello-from-xml": {
                    "hi": "hello from xml 2012-09-15T00:00:22.661Z"
                }
            }
        }
    }
}{% endhighlight %}</p>


<h3 id="basic">Instructions</h3>
<p>Most of XRLT instructions are taken from XSLT and work pretty much the
same. Some instructions have JavaScript-counterparts with the same names to use
inside JavaScript-slices.</p>

<p><ul>
    <li><code>&lt;xrl:apply&gt;</code> — apply named slice.</li>
    <li><code>&lt;xrl:attribute&gt;</code> — add an attrubute to XML element.</li>
    <li><code>&lt;xrl:choose&gt;</code> — multiple conditional tests.</li>
    <li><code>&lt;xrl:copy&gt;</code> — copy a node (without child nodes).</li>
    <li><code>&lt;xrl:copy-of&gt;</code> — copy a node (with child nodes).</li>
    <li><code>&lt;xrl:element&gt;</code> — add a dynamically named element.</li>
    <li><code>&lt;xrl:for-each&gt;</code> — loop through nodeset.</li>
    <li><code>&lt;xrl:form&gt;</code> — special kind of slices to simplify form validation, see <a href="/documentation/#forms">Form Validation</a>.</li>
    <li><code>&lt;xrl:if&gt;</code> — conditional processing.</li>
    <li><code>&lt;xrl:import&gt;</code> — import named slices from another XRLT-file.</li>
    <li><code>&lt;xrl:include&gt;</code> — include data from backend, see <a href="/documentation/#includes">Data Including</a>.</li>
    <li><code>&lt;xrl:output&gt;</code> — define output format (XML, JSON or Text).</li>
    <li><code>&lt;xrl:param&gt;</code> — parameter declaration.</li>
    <li><code>&lt;xrl:slice&gt;</code> — slice.</li>
    <li><code>&lt;xrl:text&gt;</code> — add text.</li>
    <li><code>&lt;xrl:transform&gt;</code> — transform content with a template, see <a href="/documentation/#templates">Templates</a>.</li>
    <li><code>&lt;xrl:value-of&gt;</code> — evaluate XPath expression and add evaluation result.</li>
    <li><code>&lt;xrl:variable&gt;</code> — declare variable.</li>
    <li><code>&lt;xrl:with-param&gt;</code> — pass a parameter with.</li>
</ul></p>

<h3 id="includes">Data Including</h3>
<p>Pending.</p>

<h3 id="templates">Templates</h3>
<p>Pending.</p>

<h3 id="forms">Form Validation</h3>
<p>Pending.</p>

<h3 id="request">Request Information</h3>
<p>Pending.</p>

<h3 id="caching">Caching</h3>
<p>Pending.</p>

<h3 id="rddm">Reasonably-Destructive Data Mapping</h3>
<p><a href="http://www.w3.org/2011/10/integration-workshop/s/ExperienceswithJSONandXMLTransformations.v08.pdf">Mapping
between XML and JSON is tricky</a>. We can think of non-destructive ways to map
XML to JSON, or JSON to XML. And this will bring us to non-friendly result.</p>

<p>But we don't need non-destructivity completely. User-friendly data
representation is much more important in most cases. Anyway, XRLT allows to
access data before any destructive mapping happened.</p>

<p>The structure: {% highlight javascript %}{
    "root": {
        "hello": "123",
        "world": "yo",
        "this": [
            "1", "2", 3
        ],
        "is": {
            "very": true,
            "cool": [
                4, "5", {"really": "is"}
            ]
        }
    }
}{% endhighlight %}</p>

<p>is being mapped to (and back): {% highlight xml %}<root>
    <hello>123</hello>
    <world>yo</world>
    <this>1</this>
    <this>2</this>
    <this xrl:type="number">3</this>
    <is>
        <very xrl:type="boolean">true</very>
        <cool xrl:type="number">4</cool>
        <cool>5</cool>
        <cool>
            <really>is</really>
        </cool>
    </is>
</root>{% endhighlight %}</p>

<p>This mapping is destructive, but it has pros:
<ul>
    <li>It's pretty human-readable;</li>
    <li>Works both ways (XML to JSON and JSON to XML);</li>
    <li>We have a cosy way to address elements. JavaScript to get second "is"
        looks like <code>data.root.is.cool[2].really</code>. XPath is much more
        flexible and there are many ways to get second "is", one of them is
        <code>/root/is/cool[3]/really</code>. Almost the same.</li>
</ul></p>

<h6>JSON to XML</h6>
<p>JSON to XML mapping should produce well-formed XML with two exceptions:<ol>
    <li>More than one root element is allowed.</li>
    <li>Text node is allowed as root element.</li>
</ol></p>

<p>Details described below still require more thinking, some details are
subject to be corrected.</p>

<p><code>xrl:type</code> and <code>xrl:array</code> attributes are used to make
sure we can map back to the same JSON.</p>

<p>
{% highlight javascript %}// Non-empty object creates a set of nodes:
{
    // Object's property creates a node with the same name.
    "str": "string",   // <str>string</str>
    "num": 123,        // <num xrl:type="number">123</num>
    "bool": true,      // <bool xrl:type="boolean">true</bool>
    "null": null,      // <null />
    "arr": ["1", "2"], // <arr>1</arr>
                       // <arr>2</arr>
    "empty": {},       // <empty xrl:type="object" />
    "obj": {...}       // <obj>and so on...</obj>
}


// Empty object:
{} // <object xrl:type="object" />


// Top-level string, number or boolean become text root node:
"string" // string
123      // 123
false    // false


// Object property's array:
{"array": [1, "2", false]} // <array xrl:type="number">1</array>
                           // <array>2</array>
                           // <array xrl:type="boolean">false</array>


// Top-level array or array's array:
[
    1,                     // <item xrl:array="yes" xrl:type="number">1</item>
    "2",                   // <item>2</item>
    false,                 // <item xrl:type="boolean">false</item>
    [                      // <item>
        "boo",             //     <item xrl:array="yes">boo</item>
        "moo",             //     <item>moo</item>
        {                  //     <item>
            "goo": [       //         <goo>5</goo>
                "5",       //         <goo>
                ["8", "9"] //             <item>8</item><item>9</item>
            ]              //         </goo>
        }                  //     </item>
    ]                      // </item>
]


// Top-level empty array:
[] // <item xrl:array="yes" />

{"test": []} // <test xrl:type="array" />


// Top-level null:
null // <null xrl:type="null" />

// Array of null:
[null] // <item xrl:array="yes" xrl:type="null" />

// More null:
{"test": [null, [null], []]} // <test />
                             // <test>
                             //     <item xrl:array="yes" xrl:type="null" />
                             // </test>
                             // <test xrl:type="array" />
{% endhighlight %}</p>

<h6>XML to JSON</h6>
<p>Pending.</p>

<h3 id="moar">Moar</h3>
<p>Pending.</p>
